From 7c0d6745a0df7f5c1ee1ae58a1147da755d3a1e1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fr=C3=A9d=C3=A9ric=20Pierret=20=28fepitre=29?=
 <frederic.pierret@qubes-os.org>
Date: Sat, 16 May 2020 11:38:04 +0200
Subject: [PATCH] Qubes decoration

Authors:
@marmarek

Original work done in:
- QubesOS/qubes-desktop-linux-xfce4
- QubesOS/qubes-desktop-linux-xfce4-xfwm4
---
 src/client.c   | 136 +++++++++++++++++++++++++++++-----
 src/client.h   |   2 +
 src/display.h  |   1 +
 src/frame.c    | 167 +++++++++++++++++++++++++-----------------
 src/mypixmap.c |  35 +++++++--
 src/mypixmap.h |   3 +-
 src/screen.c   |  28 +------
 src/screen.h   |  20 +++--
 src/settings.c | 195 +++++++++++++++++++++++++++++++------------------
 src/settings.h |  32 ++++++++
 10 files changed, 427 insertions(+), 192 deletions(-)

diff --git a/src/client.c b/src/client.c
index 0808e5a93..52d8dbda8 100644
--- a/src/client.c
+++ b/src/client.c
@@ -167,6 +167,93 @@ clientUpdateColormaps (Client *c)
     }
 }
 
+void
+getQubesLabel (Client *c)
+{
+    ScreenInfo *screen_info;
+    DisplayInfo *display_info;
+    Atom atom_label;
+
+    screen_info = c->screen_info;
+    display_info = screen_info->display_info;
+
+    atom_label = XInternAtom(display_info->dpy, "_QUBES_LABEL", TRUE);
+
+    if (atom_label == 0) {
+        c->qubes_label_color = QUBES_LABEL_DOM0;
+    } else {
+        Atom actual_type;
+        int actual_format;
+        unsigned long nitems = 0, bytes_left;
+        char *data = 0;
+
+        if ((XGetWindowProperty (display_info->dpy, c->window, atom_label, 0L, 1L,
+                        FALSE, AnyPropertyType, &actual_type, &actual_format, &nitems,
+                        &bytes_left, (unsigned char **) &data) == Success))
+        {
+            if (nitems != 1) {
+                // ERROR? Only Dom0 Windows don't have this property set...
+                c->qubes_label_color = QUBES_LABEL_DOM0;
+            } else {
+                int qubes_label = (int)*data;
+                if (qubes_label >= 0 && qubes_label < MAX_QUBES_LABELS) {
+                    c->qubes_label_color = qubes_label_colors[qubes_label];
+                } else {
+                    /* out of range?! */
+                    c->qubes_label_color = QUBES_LABEL_RED;
+                }
+            }
+        } else {
+            c->qubes_label_color = QUBES_LABEL_DOM0;
+        }
+    }
+}
+
+void
+getQubesVmName (Client *c)
+{
+    ScreenInfo *screen_info;
+    DisplayInfo *display_info;
+    Atom atom_vmname;
+
+    screen_info = c->screen_info;
+    display_info = screen_info->display_info;
+
+    if (c->qubes_vmname)
+        return;
+
+    atom_vmname = XInternAtom(display_info->dpy, "_QUBES_VMNAME", TRUE);
+
+    if (atom_vmname == 0) {
+        c->qubes_vmname = g_strdup("[Dom0] ");
+    } else {
+        Atom actual_type;
+        int actual_format;
+        unsigned long nitems = 0, bytes_left;
+        char *data = 0;
+
+        if ((XGetWindowProperty (display_info->dpy, c->window, atom_vmname, 0L, 0L,
+                        FALSE, AnyPropertyType, &actual_type, &actual_format, &nitems,
+                        &bytes_left, (unsigned char **) &data) == Success))
+        {
+            if (bytes_left > 0) {
+                if ((XGetWindowProperty (display_info->dpy, c->window, atom_vmname, 0L, bytes_left,
+                                FALSE, AnyPropertyType, &actual_type, &actual_format, &nitems,
+                                &bytes_left, (unsigned char **) &data) == Success))
+                {
+                    c->qubes_vmname = g_strdup_printf (_("[%s] "), data);
+                } else {
+                    c->qubes_vmname = g_strdup (_("[ERROR Reading VM name?!] "));
+                }
+            } else {
+                c->qubes_vmname = g_strdup("[Dom0] ");
+            }
+        } else {
+            c->qubes_vmname = g_strdup("[Dom0] ");
+        }
+    }
+}
+
 static gchar*
 clientCreateTitleName (Client *c, gchar *name, gchar *hostname)
 {
@@ -180,14 +267,16 @@ clientCreateTitleName (Client *c, gchar *name, gchar *hostname)
     screen_info = c->screen_info;
     display_info = screen_info->display_info;
 
+    getQubesVmName (c);
+
     if (strlen (hostname) && (display_info->hostname) && (g_ascii_strcasecmp (display_info->hostname, hostname)))
     {
         /* TRANSLATORS: "(on %s)" is like "running on" the name of the other host */
-        title = g_strdup_printf (_("%s (on %s)"), name, hostname);
+        title = g_strdup_printf (_("%s%s (on %s)"), c->qubes_vmname, name, hostname);
     }
     else
     {
-        title = g_strdup (name);
+        title = g_strdup_printf ("%s%s", c->qubes_vmname, name);
     }
 
     return title;
@@ -1354,6 +1443,10 @@ clientFree (Client *c)
     {
         g_free (c->hostname);
     }
+    if (c->qubes_vmname)
+    {
+        g_free (c->qubes_vmname);
+    }
     if (c->size)
     {
         XFree (c->size);
@@ -1467,6 +1560,7 @@ static void
 clientUpdateIconPix (Client *c)
 {
     ScreenInfo *screen_info;
+    Decoration *decoration;
     gint size;
     GdkPixbuf *icon;
     int i;
@@ -1476,12 +1570,13 @@ clientUpdateIconPix (Client *c)
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
     screen_info = c->screen_info;
+    decoration = getDecorationForColor(screen_info, c->qubes_label_color);
     for (i = 0; i < STATE_TOGGLED; i++)
     {
         xfwmPixmapFree (&c->appmenu[i]);
     }
 
-    if (xfwmPixmapNone(&screen_info->buttons[MENU_BUTTON][ACTIVE]))
+    if (xfwmPixmapNone(&decoration->buttons[MENU_BUTTON][ACTIVE]))
     {
         /* The current theme has no menu button */
         return;
@@ -1489,13 +1584,13 @@ clientUpdateIconPix (Client *c)
 
     for (i = 0; i < STATE_TOGGLED; i++)
     {
-        if (!xfwmPixmapNone(&screen_info->buttons[MENU_BUTTON][i]))
+        if (!xfwmPixmapNone(&decoration->buttons[MENU_BUTTON][i]))
         {
-            xfwmPixmapDuplicate (&screen_info->buttons[MENU_BUTTON][i], &c->appmenu[i]);
+            xfwmPixmapDuplicate (&decoration->buttons[MENU_BUTTON][i], &c->appmenu[i]);
         }
     }
-    size = MIN (screen_info->buttons[MENU_BUTTON][ACTIVE].width,
-                screen_info->buttons[MENU_BUTTON][ACTIVE].height);
+    size = MIN (decoration->buttons[MENU_BUTTON][ACTIVE].width,
+                decoration->buttons[MENU_BUTTON][ACTIVE].height);
 
     if (size > 1)
     {
@@ -1667,6 +1762,11 @@ clientFrame (DisplayInfo *display_info, Window w, gboolean recapture)
     getTransientFor (display_info, screen_info->xroot, c->window, &c->transient_for);
     XChangeSaveSet(display_info->dpy, c->window, SetModeInsert);
 
+    /* Qubes window decoration */
+    getQubesLabel(c);
+    getQubesVmName(c);
+    clientUpdateName(c);
+
     /* Initialize structure */
     c->size = NULL;
     c->flags = 0L;
@@ -3959,9 +4059,11 @@ xfwmPixmap *
 clientGetButtonPixmap (Client *c, int button, int state)
 {
     ScreenInfo *screen_info;
+    Decoration *decoration;
 
     TRACE ("button=%i, state=%i", button, state);
     screen_info = c->screen_info;
+    decoration = getDecorationForColor(screen_info, c->qubes_label_color);
     switch (button)
     {
         case MENU_BUTTON:
@@ -3973,32 +4075,32 @@ clientGetButtonPixmap (Client *c, int button, int state)
             break;
         case SHADE_BUTTON:
             if (FLAG_TEST (c->flags, CLIENT_FLAG_SHADED)
-                && (!xfwmPixmapNone(&screen_info->buttons[SHADE_BUTTON][state + STATE_TOGGLED])))
+                && (!xfwmPixmapNone(&decoration->buttons[SHADE_BUTTON][state + STATE_TOGGLED])))
             {
-                return &screen_info->buttons[SHADE_BUTTON][state + STATE_TOGGLED];
+                return &decoration->buttons[SHADE_BUTTON][state + STATE_TOGGLED];
             }
-            return &screen_info->buttons[SHADE_BUTTON][state];
+            return &decoration->buttons[SHADE_BUTTON][state];
             break;
         case STICK_BUTTON:
             if (FLAG_TEST (c->flags, CLIENT_FLAG_STICKY)
-                && (!xfwmPixmapNone(&screen_info->buttons[STICK_BUTTON][state + STATE_TOGGLED])))
+                && (!xfwmPixmapNone(&decoration->buttons[STICK_BUTTON][state + STATE_TOGGLED])))
             {
-                return &screen_info->buttons[STICK_BUTTON][state + STATE_TOGGLED];
+                return &decoration->buttons[STICK_BUTTON][state + STATE_TOGGLED];
             }
-            return &screen_info->buttons[STICK_BUTTON][state];
+            return &decoration->buttons[STICK_BUTTON][state];
             break;
         case MAXIMIZE_BUTTON:
             if (FLAG_TEST (c->flags, CLIENT_FLAG_MAXIMIZED)
-                && (!xfwmPixmapNone(&screen_info->buttons[MAXIMIZE_BUTTON][state + STATE_TOGGLED])))
+                && (!xfwmPixmapNone(&decoration->buttons[MAXIMIZE_BUTTON][state + STATE_TOGGLED])))
             {
-                return &screen_info->buttons[MAXIMIZE_BUTTON][state + STATE_TOGGLED];
+                return &decoration->buttons[MAXIMIZE_BUTTON][state + STATE_TOGGLED];
             }
-            return &screen_info->buttons[MAXIMIZE_BUTTON][state];
+            return &decoration->buttons[MAXIMIZE_BUTTON][state];
             break;
         default:
             break;
     }
-    return &screen_info->buttons[button][state];
+    return &decoration->buttons[button][state];
 }
 
 int
diff --git a/src/client.h b/src/client.h
index 89d2d82f3..43d71d4cd 100644
--- a/src/client.h
+++ b/src/client.h
@@ -331,6 +331,8 @@ struct _Client
     gint struts[STRUTS_SIZE];
     gchar *hostname;
     gchar *name;
+    gchar *qubes_vmname;
+    guint qubes_label_color;
     guint32 user_time;
     GPid pid;
     guint32 ping_time;
diff --git a/src/display.h b/src/display.h
index 23e0f21e5..1d6ffe66b 100644
--- a/src/display.h
+++ b/src/display.h
@@ -279,6 +279,7 @@ typedef struct _Client            Client;
 typedef struct _DisplayInfo       DisplayInfo;
 typedef struct _xfwmPixmap        xfwmPixmap;
 typedef struct _XfwmParams        XfwmParams;
+typedef struct _Decoration        Decoration;
 typedef struct _ScreenInfo        ScreenInfo;
 typedef struct _Settings          Settings;
 
diff --git a/src/frame.c b/src/frame.c
index 4d1870425..dee79071c 100644
--- a/src/frame.c
+++ b/src/frame.c
@@ -48,6 +48,7 @@ typedef struct
 static int
 frameDecorationBorderTop (ScreenInfo *screen_info)
 {
+    Decoration *decoration;
     TRACE ("entering");
 
     g_return_val_if_fail (screen_info != NULL, 0);
@@ -57,9 +58,11 @@ frameDecorationBorderTop (ScreenInfo *screen_info)
 static int
 frameBorderTop (Client * c)
 {
+    Decoration *decoration;
     g_return_val_if_fail (c != NULL, 0);
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
+    decoration = getDecorationForColor(c->screen_info, c->qubes_label_color);
     if (FLAG_TEST (c->xfwm_flags, XFWM_FLAG_HAS_BORDER)
         && !FLAG_TEST (c->flags, CLIENT_FLAG_FULLSCREEN)
         && FLAG_TEST_ALL (c->flags, CLIENT_FLAG_MAXIMIZED)
@@ -73,30 +76,34 @@ frameBorderTop (Client * c)
 static int
 frameTopLeftWidth (Client * c, int state)
 {
+    Decoration *decoration;
     g_return_val_if_fail (c != NULL, 0);
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
+    decoration = getDecorationForColor(c->screen_info, c->qubes_label_color);
     if (FLAG_TEST_ALL (c->flags, CLIENT_FLAG_MAXIMIZED)
         && c->screen_info->params->borderless_maximize)
     {
         return 0;
     }
-    return c->screen_info->corners[CORNER_TOP_LEFT][state].width;
+    return decoration->corners[CORNER_TOP_LEFT][state].width;
 
 }
 
 static int
 frameTopRightWidth (Client * c, int state)
 {
+    Decoration *decoration;
     g_return_val_if_fail (c != NULL, 0);
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
+    decoration = getDecorationForColor(c->screen_info, c->qubes_label_color);
     if (FLAG_TEST_ALL (c->flags, CLIENT_FLAG_MAXIMIZED)
         && c->screen_info->params->borderless_maximize)
     {
         return 0;
     }
-    return c->screen_info->corners[CORNER_TOP_RIGHT][state].width;
+    return decoration->corners[CORNER_TOP_RIGHT][state].width;
 }
 
 static int
@@ -117,6 +124,7 @@ static void
 frameFillTitlePixmap (Client * c, int state, int part, int x, int w, int h, xfwmPixmap * title_pm, xfwmPixmap * top_pm)
 {
     ScreenInfo *screen_info;
+    Decoration *decoration;
 
     g_return_if_fail (c);
     g_return_if_fail (title_pm);
@@ -124,22 +132,24 @@ frameFillTitlePixmap (Client * c, int state, int part, int x, int w, int h, xfwm
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
     screen_info = c->screen_info;
+    decoration = getDecorationForColor(screen_info, c->qubes_label_color);
 
-    if (!xfwmPixmapNone(&screen_info->top[part][state]))
+    if (!xfwmPixmapNone(&decoration->top[part][state]))
     {
-        xfwmPixmapFill (&screen_info->top[part][state], top_pm, x, 0, w, h);
+        xfwmPixmapFill (&decoration->top[part][state], top_pm, x, 0, w, h);
     }
     else
     {
-        xfwmPixmapFill (&screen_info->title[part][state], top_pm, x, 0, w, h);
+        xfwmPixmapFill (&decoration->title[part][state], top_pm, x, 0, w, h);
     }
-    xfwmPixmapFill (&screen_info->title[part][state], title_pm, x, 0, w, frameDecorationTop(screen_info));
+    xfwmPixmapFill (&decoration->title[part][state], title_pm, x, 0, w, frameDecorationTop(screen_info));
 }
 
 static void
 frameCreateTitlePixmap (Client * c, int state, int left, int right, xfwmPixmap * title_pm, xfwmPixmap * top_pm)
 {
     ScreenInfo *screen_info;
+    Decoration *decoration;
     cairo_surface_t *surface;
     cairo_t *cr;
     PangoLayout *layout;
@@ -154,6 +164,7 @@ frameCreateTitlePixmap (Client * c, int state, int left, int right, xfwmPixmap *
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
     screen_info = c->screen_info;
+    decoration = getDecorationForColor(screen_info, c->qubes_label_color);
 
     if (left > right)
     {
@@ -212,9 +223,9 @@ frameCreateTitlePixmap (Client * c, int state, int left, int right, xfwmPixmap *
         title_y = MAX (0, frameDecorationTop(screen_info) - title_height);
     }
 
-    if (!xfwmPixmapNone(&screen_info->top[3][ACTIVE]))
+    if (!xfwmPixmapNone(&decoration->top[3][ACTIVE]))
     {
-        top_height = screen_info->top[3][ACTIVE].height;
+        top_height = decoration->top[3][ACTIVE].height;
     }
     else if (frameDecorationBorderTop(c->screen_info) > 0)
     {
@@ -230,8 +241,8 @@ frameCreateTitlePixmap (Client * c, int state, int left, int right, xfwmPixmap *
     }
 
     w1 = 0;
-    w2 = screen_info->title[TITLE_2][state].width;
-    w4 = screen_info->title[TITLE_4][state].width;
+    w2 = decoration->title[TITLE_2][state].width;
+    w4 = decoration->title[TITLE_4][state].width;
 
     if (screen_info->params->full_width_title)
     {
@@ -459,6 +470,7 @@ static void
 frameSetShape (Client * c, int state, FramePixmap * frame_pix, int button_x[BUTTON_COUNT])
 {
     ScreenInfo *screen_info;
+    Decoration *decoration;
     DisplayInfo *display_info;
     XRectangle rect;
     xfwmPixmap *my_pixmap;
@@ -468,6 +480,7 @@ frameSetShape (Client * c, int state, FramePixmap * frame_pix, int button_x[BUTT
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
     screen_info = c->screen_info;
+    decoration = getDecorationForColor(screen_info, c->qubes_label_color);
     display_info = screen_info->display_info;
 
     if (!display_info->have_shape)
@@ -541,25 +554,25 @@ frameSetShape (Client * c, int state, FramePixmap * frame_pix, int button_x[BUTT
         if (xfwmWindowVisible (&c->corners[CORNER_BOTTOM_LEFT]))
         {
             XShapeCombineMask (display_info->dpy, MYWINDOW_XWINDOW (c->corners[CORNER_BOTTOM_LEFT]),
-                               ShapeBounding, 0, 0, screen_info->corners[CORNER_BOTTOM_LEFT][state].mask, ShapeSet);
+                               ShapeBounding, 0, 0, decoration->corners[CORNER_BOTTOM_LEFT][state].mask, ShapeSet);
         }
 
         if (xfwmWindowVisible (&c->corners[CORNER_BOTTOM_RIGHT]))
         {
             XShapeCombineMask (display_info->dpy, MYWINDOW_XWINDOW (c->corners[CORNER_BOTTOM_RIGHT]),
-                               ShapeBounding, 0, 0, screen_info->corners[CORNER_BOTTOM_RIGHT][state].mask, ShapeSet);
+                               ShapeBounding, 0, 0, decoration->corners[CORNER_BOTTOM_RIGHT][state].mask, ShapeSet);
         }
 
         if (xfwmWindowVisible (&c->corners[CORNER_TOP_LEFT]))
         {
             XShapeCombineMask (display_info->dpy, MYWINDOW_XWINDOW (c->corners[CORNER_TOP_LEFT]),
-                               ShapeBounding, 0, 0, screen_info->corners[CORNER_TOP_LEFT][state].mask, ShapeSet);
+                               ShapeBounding, 0, 0, decoration->corners[CORNER_TOP_LEFT][state].mask, ShapeSet);
         }
 
         if (xfwmWindowVisible (&c->corners[CORNER_TOP_RIGHT]))
         {
             XShapeCombineMask (display_info->dpy, MYWINDOW_XWINDOW (c->corners[CORNER_TOP_RIGHT]),
-                               ShapeBounding, 0, 0, screen_info->corners[CORNER_TOP_RIGHT][state].mask, ShapeSet);
+                               ShapeBounding, 0, 0, decoration->corners[CORNER_TOP_RIGHT][state].mask, ShapeSet);
         }
 
         for (i = 0; i < BUTTON_COUNT; i++)
@@ -573,48 +586,48 @@ frameSetShape (Client * c, int state, FramePixmap * frame_pix, int button_x[BUTT
         }
 
         if (xfwmWindowVisible (&c->corners[CORNER_TOP_LEFT]) &&
-            (screen_info->corners[CORNER_TOP_LEFT][state].height > frameHeight (c) - frameBottom (c) + 1))
+            (decoration->corners[CORNER_TOP_LEFT][state].height > frameHeight (c) - frameBottom (c) + 1))
         {
             rect.x      = 0;
             rect.y      = frameHeight (c) - frameBottom (c) + 1;
             rect.width  = frameTopLeftWidth (c, state);
-            rect.height = screen_info->corners[CORNER_TOP_LEFT][state].height
+            rect.height = decoration->corners[CORNER_TOP_LEFT][state].height
                            - (frameHeight (c) - frameBottom (c) + 1);
             XShapeCombineRectangles (display_info->dpy, MYWINDOW_XWINDOW (c->corners[CORNER_TOP_LEFT]),
                                      ShapeBounding, 0, 0, &rect, 1, ShapeSubtract, 0);
         }
 
         if (xfwmWindowVisible (&c->corners[CORNER_TOP_RIGHT]) &&
-            (screen_info->corners[CORNER_TOP_RIGHT][state].height > frameHeight (c) - frameBottom (c) + 1))
+            (decoration->corners[CORNER_TOP_RIGHT][state].height > frameHeight (c) - frameBottom (c) + 1))
         {
             rect.x      = 0;
             rect.y      = frameHeight (c) - frameBottom (c) + 1;
             rect.width  = frameTopRightWidth (c, state);
-            rect.height = screen_info->corners[CORNER_TOP_RIGHT][state].height
+            rect.height = decoration->corners[CORNER_TOP_RIGHT][state].height
                            - (frameHeight (c) - frameBottom (c) + 1);
             XShapeCombineRectangles (display_info->dpy, MYWINDOW_XWINDOW (c->corners[CORNER_TOP_RIGHT]),
                                      ShapeBounding, 0, 0, &rect, 1, ShapeSubtract, 0);
         }
 
         if (xfwmWindowVisible (&c->corners[CORNER_BOTTOM_LEFT]) &&
-            (screen_info->corners[CORNER_BOTTOM_LEFT][state].height > frameHeight (c) - frameTop (c) + 1))
+            (decoration->corners[CORNER_BOTTOM_LEFT][state].height > frameHeight (c) - frameTop (c) + 1))
         {
             rect.x      = 0;
             rect.y      = 0;
-            rect.width  = screen_info->corners[CORNER_BOTTOM_LEFT][state].width;
-            rect.height = screen_info->corners[CORNER_BOTTOM_LEFT][state].height
+            rect.width  = decoration->corners[CORNER_BOTTOM_LEFT][state].width;
+            rect.height = decoration->corners[CORNER_BOTTOM_LEFT][state].height
                            - (frameHeight (c) - frameTop (c) + 1);
             XShapeCombineRectangles (display_info->dpy, MYWINDOW_XWINDOW (c->corners[CORNER_BOTTOM_LEFT]),
                                      ShapeBounding, 0, 0, &rect, 1, ShapeSubtract, 0);
         }
 
         if (xfwmWindowVisible (&c->corners[CORNER_BOTTOM_RIGHT]) &&
-            (screen_info->corners[CORNER_BOTTOM_RIGHT][state].height > frameHeight (c) - frameTop (c) + 1))
+            (decoration->corners[CORNER_BOTTOM_RIGHT][state].height > frameHeight (c) - frameTop (c) + 1))
         {
             rect.x      = 0;
             rect.y      = 0;
-            rect.width  = screen_info->corners[CORNER_BOTTOM_RIGHT][state].width;
-            rect.height = screen_info->corners[CORNER_BOTTOM_RIGHT][state].height
+            rect.width  = decoration->corners[CORNER_BOTTOM_RIGHT][state].width;
+            rect.height = decoration->corners[CORNER_BOTTOM_RIGHT][state].height
                            - (frameHeight (c) - frameTop (c) + 1);
             XShapeCombineRectangles (display_info->dpy, MYWINDOW_XWINDOW (c->corners[CORNER_BOTTOM_RIGHT]),
                                      ShapeBounding, 0, 0, &rect, 1, ShapeSubtract, 0);
@@ -652,7 +665,7 @@ frameSetShape (Client * c, int state, FramePixmap * frame_pix, int button_x[BUTT
         if (xfwmWindowVisible (&c->sides[SIDE_BOTTOM]))
         {
             XShapeCombineShape (display_info->dpy, screen_info->shape_win, ShapeBounding,
-                                screen_info->corners[CORNER_BOTTOM_LEFT][state].width,
+                                decoration->corners[CORNER_BOTTOM_LEFT][state].width,
                                 frameHeight (c) - frameBottom (c),
                                 MYWINDOW_XWINDOW (c->sides[SIDE_BOTTOM]), ShapeBounding, ShapeUnion);
         }
@@ -660,7 +673,7 @@ frameSetShape (Client * c, int state, FramePixmap * frame_pix, int button_x[BUTT
         if (xfwmWindowVisible (&c->sides[SIDE_TOP]))
         {
             XShapeCombineShape (display_info->dpy, screen_info->shape_win, ShapeBounding,
-                                screen_info->corners[CORNER_BOTTOM_LEFT][state].width,
+                                decoration->corners[CORNER_BOTTOM_LEFT][state].width,
                                 frameTop (c) - frameBottom (c),
                                 MYWINDOW_XWINDOW (c->sides[SIDE_TOP]), ShapeBounding, ShapeUnion);
         }
@@ -668,15 +681,15 @@ frameSetShape (Client * c, int state, FramePixmap * frame_pix, int button_x[BUTT
         if (xfwmWindowVisible (&c->corners[CORNER_BOTTOM_LEFT]))
         {
             XShapeCombineShape (display_info->dpy, screen_info->shape_win, ShapeBounding, 0,
-                                frameHeight (c) - screen_info->corners[CORNER_BOTTOM_LEFT][state].height,
+                                frameHeight (c) - decoration->corners[CORNER_BOTTOM_LEFT][state].height,
                                 MYWINDOW_XWINDOW (c->corners[CORNER_BOTTOM_LEFT]), ShapeBounding, ShapeUnion);
         }
 
         if (xfwmWindowVisible (&c->corners[CORNER_BOTTOM_RIGHT]))
         {
             XShapeCombineShape (display_info->dpy, screen_info->shape_win, ShapeBounding,
-                                frameWidth (c) - screen_info->corners[CORNER_BOTTOM_RIGHT][state].width,
-                                frameHeight (c) - screen_info->corners[CORNER_BOTTOM_RIGHT][state].height,
+                                frameWidth (c) - decoration->corners[CORNER_BOTTOM_RIGHT][state].width,
+                                frameHeight (c) - decoration->corners[CORNER_BOTTOM_RIGHT][state].height,
                                 MYWINDOW_XWINDOW (c->corners[CORNER_BOTTOM_RIGHT]), ShapeBounding, ShapeUnion);
         }
 
@@ -692,7 +705,7 @@ frameSetShape (Client * c, int state, FramePixmap * frame_pix, int button_x[BUTT
             if (xfwmWindowVisible (&c->buttons[i]))
             {
                 XShapeCombineShape (display_info->dpy, screen_info->shape_win, ShapeBounding, button_x[i],
-                                    (frameTop (c) - screen_info->buttons[i][state].height + 1) / 2,
+                                    (frameTop (c) - decoration->buttons[i][state].height + 1) / 2,
                                     MYWINDOW_XWINDOW (c->buttons[i]), ShapeBounding, ShapeUnion);
             }
         }
@@ -711,6 +724,7 @@ static void
 frameDrawWin (Client * c)
 {
     ScreenInfo *screen_info;
+    Decoration *decoration;
     FramePixmap frame_pix;
     xfwmPixmap *my_pixmap;
     gint state, x, button, left, right;
@@ -727,6 +741,7 @@ frameDrawWin (Client * c)
     frameClearQueueDraw (c);
 
     screen_info = c->screen_info;
+    decoration = getDecorationForColor(screen_info, c->qubes_label_color);
     requires_clearing = FALSE;
     width_changed = FALSE;
     height_changed = FALSE;
@@ -818,7 +833,7 @@ frameDrawWin (Client * c)
             }
             else if (button >= 0)
             {
-                if (x + screen_info->buttons[button][state].width + screen_info->params->button_spacing < right)
+                if (x + decoration->buttons[button][state].width + screen_info->params->button_spacing < right)
                 {
                     my_pixmap = clientGetButtonPixmap (c, button, clientGetButtonState (c, button, state));
                     if (!xfwmPixmapNone(my_pixmap))
@@ -826,11 +841,11 @@ frameDrawWin (Client * c)
                         xfwmWindowSetBG (&c->buttons[button], my_pixmap);
                     }
                     xfwmWindowShow (&c->buttons[button], x,
-                        ((frameDecorationTop(screen_info) - screen_info->buttons[button][state].height + 1) / 2) - frameBorderTop (c),
-                        screen_info->buttons[button][state].width,
-                        screen_info->buttons[button][state].height, TRUE);
+                        ((frameDecorationTop(screen_info) - decoration->buttons[button][state].height + 1) / 2) - frameBorderTop (c),
+                        decoration->buttons[button][state].width,
+                        decoration->buttons[button][state].height, TRUE);
                     button_x[button] = x;
-                    x = x + screen_info->buttons[button][state].width +
+                    x = x + decoration->buttons[button][state].width +
                         screen_info->params->button_spacing;
                 }
                 else
@@ -853,19 +868,19 @@ frameDrawWin (Client * c)
             }
             else if (button >= 0)
             {
-                if (x - screen_info->buttons[button][state].width - screen_info->params->button_spacing > left)
+                if (x - decoration->buttons[button][state].width - screen_info->params->button_spacing > left)
                 {
                     my_pixmap = clientGetButtonPixmap (c, button, clientGetButtonState (c, button, state));
                     if (!xfwmPixmapNone(my_pixmap))
                     {
                         xfwmWindowSetBG (&c->buttons[button], my_pixmap);
                     }
-                    x = x - screen_info->buttons[button][state].width -
+                    x = x - decoration->buttons[button][state].width -
                         screen_info->params->button_spacing;
                     xfwmWindowShow (&c->buttons[button], x,
-                        ((frameDecorationTop(screen_info) - screen_info->buttons[button][state].height + 1) / 2) - frameBorderTop (c),
-                        screen_info->buttons[button][state].width,
-                        screen_info->buttons[button][state].height, TRUE);
+                        ((frameDecorationTop(screen_info) - decoration->buttons[button][state].height + 1) / 2) - frameBorderTop (c),
+                        decoration->buttons[button][state].width,
+                        decoration->buttons[button][state].height, TRUE);
                     button_x[button] = x;
                 }
                 else
@@ -879,12 +894,12 @@ frameDrawWin (Client * c)
 
         top_width = frameWidth (c) - frameTopLeftWidth (c, state) - frameTopRightWidth (c, state);
         bottom_width = frameWidth (c) -
-            screen_info->corners[CORNER_BOTTOM_LEFT][state].width -
-            screen_info->corners[CORNER_BOTTOM_RIGHT][state].width;
+            decoration->corners[CORNER_BOTTOM_LEFT][state].width -
+            decoration->corners[CORNER_BOTTOM_RIGHT][state].width;
         left_height = frameHeight (c) - frameTop (c) -
-            screen_info->corners[CORNER_BOTTOM_LEFT][state].height;
+            decoration->corners[CORNER_BOTTOM_LEFT][state].height;
         right_height = frameHeight (c) - frameTop (c) -
-            screen_info->corners[CORNER_BOTTOM_RIGHT][state].height;
+            decoration->corners[CORNER_BOTTOM_RIGHT][state].height;
 
         xfwmPixmapInit (screen_info, &frame_pix.pm_title);
         xfwmPixmapInit (screen_info, &frame_pix.pm_sides[SIDE_TOP]);
@@ -903,13 +918,13 @@ frameDrawWin (Client * c)
         if (requires_clearing)
         {
             xfwmWindowSetBG (&c->corners[CORNER_TOP_LEFT],
-                &screen_info->corners[CORNER_TOP_LEFT][state]);
+                &decoration->corners[CORNER_TOP_LEFT][state]);
             xfwmWindowSetBG (&c->corners[CORNER_TOP_RIGHT],
-                &screen_info->corners[CORNER_TOP_RIGHT][state]);
+                &decoration->corners[CORNER_TOP_RIGHT][state]);
             xfwmWindowSetBG (&c->corners[CORNER_BOTTOM_LEFT],
-                &screen_info->corners[CORNER_BOTTOM_LEFT][state]);
+                &decoration->corners[CORNER_BOTTOM_LEFT][state]);
             xfwmWindowSetBG (&c->corners[CORNER_BOTTOM_RIGHT],
-                &screen_info->corners[CORNER_BOTTOM_RIGHT][state]);
+                &decoration->corners[CORNER_BOTTOM_RIGHT][state]);
         }
 
         if (FLAG_TEST_ALL (c->flags, CLIENT_FLAG_MAXIMIZED)
@@ -935,7 +950,7 @@ frameDrawWin (Client * c)
             {
                 xfwmPixmapCreate (screen_info, &frame_pix.pm_sides[SIDE_LEFT],
                     frameLeft (c), left_height);
-                xfwmPixmapFill (&screen_info->sides[SIDE_LEFT][state],
+                xfwmPixmapFill (&decoration->sides[SIDE_LEFT][state],
                     &frame_pix.pm_sides[SIDE_LEFT],
                     0, 0, frameLeft (c), left_height);
                 xfwmWindowSetBG (&c->sides[SIDE_LEFT],
@@ -945,7 +960,7 @@ frameDrawWin (Client * c)
 
                 xfwmPixmapCreate (screen_info, &frame_pix.pm_sides[SIDE_RIGHT],
                     frameRight (c), right_height);
-                xfwmPixmapFill (&screen_info->sides[SIDE_RIGHT][state],
+                xfwmPixmapFill (&decoration->sides[SIDE_RIGHT][state],
                     &frame_pix.pm_sides[SIDE_RIGHT],
                     0, 0, frameRight (c), right_height);
                 xfwmWindowSetBG (&c->sides[SIDE_RIGHT],
@@ -957,13 +972,13 @@ frameDrawWin (Client * c)
 
             xfwmPixmapCreate (screen_info, &frame_pix.pm_sides[SIDE_BOTTOM],
                 bottom_width, frameBottom (c));
-            xfwmPixmapFill (&screen_info->sides[SIDE_BOTTOM][state],
+            xfwmPixmapFill (&decoration->sides[SIDE_BOTTOM][state],
                 &frame_pix.pm_sides[SIDE_BOTTOM],
                 0, 0, bottom_width, frameBottom (c));
             xfwmWindowSetBG (&c->sides[SIDE_BOTTOM],
                 &frame_pix.pm_sides[SIDE_BOTTOM]);
             xfwmWindowShow (&c->sides[SIDE_BOTTOM],
-                screen_info->corners[CORNER_BOTTOM_LEFT][state].width,
+                decoration->corners[CORNER_BOTTOM_LEFT][state].width,
                 frameHeight (c) - frameBottom (c), bottom_width, frameBottom (c),
                 (requires_clearing | width_changed));
 
@@ -971,7 +986,7 @@ frameDrawWin (Client * c)
             {
                 xfwmWindowSetBG (&c->sides[SIDE_TOP], &frame_pix.pm_sides[SIDE_TOP]);
                 xfwmWindowShow (&c->sides[SIDE_TOP],
-                    screen_info->corners[CORNER_TOP_LEFT][state].width,
+                    decoration->corners[CORNER_TOP_LEFT][state].width,
                     0, top_width, frame_pix.pm_sides[SIDE_TOP].height,
                     (requires_clearing | width_changed));
             }
@@ -982,29 +997,29 @@ frameDrawWin (Client * c)
 
             xfwmWindowShow (&c->corners[CORNER_TOP_LEFT], 0, 0,
                 frameTopLeftWidth (c, state),
-                screen_info->corners[CORNER_TOP_LEFT][state].height,
+                decoration->corners[CORNER_TOP_LEFT][state].height,
                 requires_clearing);
 
             xfwmWindowShow (&c->corners[CORNER_TOP_RIGHT],
                 frameWidth (c) - frameTopRightWidth (c, state),
                 0, frameTopRightWidth (c, state),
-                screen_info->corners[CORNER_TOP_RIGHT][state].height,
+                decoration->corners[CORNER_TOP_RIGHT][state].height,
                 requires_clearing);
 
             xfwmWindowShow (&c->corners[CORNER_BOTTOM_LEFT], 0,
                 frameHeight (c) -
-                screen_info->corners[CORNER_BOTTOM_LEFT][state].height,
-                screen_info->corners[CORNER_BOTTOM_LEFT][state].width,
-                screen_info->corners[CORNER_BOTTOM_LEFT][state].height,
+                decoration->corners[CORNER_BOTTOM_LEFT][state].height,
+                decoration->corners[CORNER_BOTTOM_LEFT][state].width,
+                decoration->corners[CORNER_BOTTOM_LEFT][state].height,
                 requires_clearing);
 
             xfwmWindowShow (&c->corners[CORNER_BOTTOM_RIGHT],
                 frameWidth (c) -
-                screen_info->corners[CORNER_BOTTOM_RIGHT][state].width,
+                decoration->corners[CORNER_BOTTOM_RIGHT][state].width,
                 frameHeight (c) -
-                screen_info->corners[CORNER_BOTTOM_RIGHT][state].height,
-                screen_info->corners[CORNER_BOTTOM_RIGHT][state].width,
-                screen_info->corners[CORNER_BOTTOM_RIGHT][state].height,
+                decoration->corners[CORNER_BOTTOM_RIGHT][state].height,
+                decoration->corners[CORNER_BOTTOM_RIGHT][state].width,
+                decoration->corners[CORNER_BOTTOM_RIGHT][state].height,
                 requires_clearing);
         }
         frameSetShape (c, state, &frame_pix, button_x);
@@ -1064,51 +1079,61 @@ update_frame_idle_cb (gpointer data)
 int
 frameDecorationLeft (ScreenInfo *screen_info)
 {
+    Decoration *decoration;
     TRACE ("entering");
 
     g_return_val_if_fail (screen_info != NULL, 0);
-    return screen_info->sides[SIDE_LEFT][ACTIVE].width;
+    decoration = getDecorationForColor(screen_info, QUBES_LABEL_DOM0);
+    return decoration->sides[SIDE_LEFT][ACTIVE].width;
 }
 
 int
 frameDecorationRight (ScreenInfo *screen_info)
 {
+    Decoration *decoration;
     TRACE ("entering");
 
     g_return_val_if_fail (screen_info != NULL, 0);
-    return screen_info->sides[SIDE_RIGHT][ACTIVE].width;
+    decoration = getDecorationForColor(screen_info, QUBES_LABEL_DOM0);
+    return decoration->sides[SIDE_RIGHT][ACTIVE].width;
 }
 
 int
 frameDecorationTop (ScreenInfo *screen_info)
 {
+    Decoration *decoration;
     TRACE ("entering");
 
     g_return_val_if_fail (screen_info != NULL, 0);
-    return screen_info->title[TITLE_3][ACTIVE].height;
+    decoration = getDecorationForColor(screen_info, QUBES_LABEL_DOM0);
+    return decoration->title[TITLE_3][ACTIVE].height;
 }
 
 int
 frameDecorationBottom (ScreenInfo *screen_info)
 {
+    Decoration *decoration;
     TRACE ("entering");
 
     g_return_val_if_fail (screen_info != NULL, 0);
-    return screen_info->sides[SIDE_BOTTOM][ACTIVE].height;
+    decoration = getDecorationForColor(screen_info, QUBES_LABEL_DOM0);
+    return decoration->sides[SIDE_BOTTOM][ACTIVE].height;
 }
 
 int
 frameLeft (Client * c)
 {
+    Decoration *decoration;
     g_return_val_if_fail (c != NULL, 0);
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
+    decoration = getDecorationForColor(c->screen_info, c->qubes_label_color);
     if (FLAG_TEST (c->xfwm_flags, XFWM_FLAG_HAS_BORDER)
         && !FLAG_TEST (c->flags, CLIENT_FLAG_FULLSCREEN)
         && (!FLAG_TEST_ALL (c->flags, CLIENT_FLAG_MAXIMIZED)
             || !(c->screen_info->params->borderless_maximize)))
     {
-        return c->screen_info->sides[SIDE_LEFT][ACTIVE].width;
+        return decoration->sides[SIDE_LEFT][ACTIVE].width;
     }
     return 0;
 }
@@ -1116,15 +1141,17 @@ frameLeft (Client * c)
 int
 frameRight (Client * c)
 {
+    Decoration *decoration;
     g_return_val_if_fail (c != NULL, 0);
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
+    decoration = getDecorationForColor(c->screen_info, c->qubes_label_color);
     if (FLAG_TEST (c->xfwm_flags, XFWM_FLAG_HAS_BORDER)
         && !FLAG_TEST (c->flags, CLIENT_FLAG_FULLSCREEN)
         && (!FLAG_TEST_ALL (c->flags, CLIENT_FLAG_MAXIMIZED)
             || !(c->screen_info->params->borderless_maximize)))
     {
-        return c->screen_info->sides[SIDE_RIGHT][ACTIVE].width;
+        return decoration->sides[SIDE_RIGHT][ACTIVE].width;
     }
     return 0;
 }
@@ -1145,15 +1172,17 @@ frameTop (Client * c)
 int
 frameBottom (Client * c)
 {
+    Decoration *decoration;
     g_return_val_if_fail (c != NULL, 0);
     TRACE ("client \"%s\" (0x%lx)", c->name, c->window);
 
+    decoration = getDecorationForColor(c->screen_info, c->qubes_label_color);
     if (FLAG_TEST (c->xfwm_flags, XFWM_FLAG_HAS_BORDER)
         && !FLAG_TEST (c->flags, CLIENT_FLAG_FULLSCREEN)
         && (!FLAG_TEST_ALL (c->flags, CLIENT_FLAG_MAXIMIZED)
             || !(c->screen_info->params->borderless_maximize)))
     {
-        return c->screen_info->sides[SIDE_BOTTOM][ACTIVE].height;
+        return decoration->sides[SIDE_BOTTOM][ACTIVE].height;
     }
     return 0;
 }
diff --git a/src/mypixmap.c b/src/mypixmap.c
index e5d23560a..f60413770 100644
--- a/src/mypixmap.c
+++ b/src/mypixmap.c
@@ -44,6 +44,7 @@
 #include <gdk/gdkx.h>
 #include <cairo/cairo-xlib.h>
 #include <libxfce4util/libxfce4util.h>
+#include <gtk/gtk.h>
 #include <stdlib.h>
 #include <stdio.h>
 
@@ -516,7 +517,7 @@ file_buffer (enum buf_op op, gpointer handle)
 
 /* This function does all the work. */
 static GdkPixbuf *
-pixbuf_create_from_xpm (gpointer handle, xfwmColorSymbol *color_sym)
+pixbuf_create_from_xpm (gpointer handle, xfwmColorSymbol *color_sym, gboolean override, gdouble override_h, gdouble override_s, gdouble override_v)
 {
     gchar pixel_str[32];
     const gchar *buffer;
@@ -606,6 +607,18 @@ pixbuf_create_from_xpm (gpointer handle, xfwmColorSymbol *color_sym)
             color->red = 0;
             color->green = 0;
             color->blue = 0;
+        } else if (override) {
+            gdouble h, s, v, new_r, new_g, new_b;
+            /* override color - for Qubes labels */
+            gtk_rgb_to_hsv(
+                    1.0*color->red/0xFFFF,
+                    1.0*color->green/0xFFFF,
+                    1.0*color->blue/0xFFFF,
+                    &h, &s, &v);
+            gtk_hsv_to_rgb(override_h, override_s, v, &new_r, &new_g, &new_b);
+            color->red = new_r*0xFFFF;
+            color->green = new_g*0xFFFF;
+            color->blue = new_b*0xFFFF;
         }
 
         g_free (color_name);
@@ -677,7 +690,8 @@ pixbuf_create_from_xpm (gpointer handle, xfwmColorSymbol *color_sym)
 
 
 static GdkPixbuf *
-xpm_image_load (const char *filename, xfwmColorSymbol *color_sym)
+xpm_image_load (const char *filename, xfwmColorSymbol *color_sym,
+        gboolean override, gdouble override_h, gdouble override_s, gdouble override_v)
 {
     guchar buffer[1024];
     GdkPixbuf *pixbuf;
@@ -703,7 +717,8 @@ xpm_image_load (const char *filename, xfwmColorSymbol *color_sym)
     fseek (f, 0, SEEK_SET);
     memset (&h, 0, sizeof (h));
     h.infile = f;
-    pixbuf = pixbuf_create_from_xpm (&h, color_sym);
+    pixbuf = pixbuf_create_from_xpm (&h, color_sym, override,
+            override_h, override_s, override_v);
     g_free (h.buffer);
     fclose (f);
 
@@ -949,7 +964,7 @@ xfwmPixmapRenderGdkPixbuf (xfwmPixmap * pm, GdkPixbuf *pixbuf)
 }
 
 gboolean
-xfwmPixmapLoad (ScreenInfo * screen_info, xfwmPixmap * pm, const gchar * dir, const gchar * file, xfwmColorSymbol * cs)
+xfwmPixmapLoad (ScreenInfo * screen_info, xfwmPixmap * pm, const gchar * dir, const gchar * file, xfwmColorSymbol * cs, guint label_color)
 {
     gchar *filename;
     gchar *filexpm;
@@ -969,7 +984,17 @@ xfwmPixmapLoad (ScreenInfo * screen_info, xfwmPixmap * pm, const gchar * dir, co
     filexpm = g_strdup_printf ("%s.%s", file, "xpm");
     filename = g_build_filename (dir, filexpm, NULL);
     g_free (filexpm);
-    pixbuf = xpm_image_load (filename, cs);
+    if (label_color != 0xFFFFFFFF) {
+        gdouble h, s, v;
+        gtk_rgb_to_hsv(
+                1.0*((label_color & 0xFF0000) >> 16)/0xFF,
+                1.0*((label_color & 0x00FF00) >>  8)/0xFF,
+                1.0*((label_color & 0x0000FF) >>  0)/0xFF,
+                &h, &s, &v);
+        pixbuf = xpm_image_load (filename, cs, TRUE, h, s, v);
+    } else {
+        pixbuf = xpm_image_load (filename, cs, FALSE, 0, 0, 0);
+    }
     g_free (filename);
 
     /* Compose with other image formats, if any available. */
diff --git a/src/mypixmap.h b/src/mypixmap.h
index 1b05cface..f089e9a1b 100644
--- a/src/mypixmap.h
+++ b/src/mypixmap.h
@@ -62,7 +62,8 @@ gboolean                 xfwmPixmapLoad                         (ScreenInfo *,
                                                                  xfwmPixmap *,
                                                                  const gchar *,
                                                                  const gchar *,
-                                                                 xfwmColorSymbol *);
+                                                                 xfwmColorSymbol *,
+                                                                 guint label_color);
 void                     xfwmPixmapCreate                       (ScreenInfo *,
                                                                  xfwmPixmap *,
                                                                  gint,
diff --git a/src/screen.c b/src/screen.c
index ebe150508..e46932dcf 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -170,7 +170,7 @@ myScreenInit (DisplayInfo *display_info, GdkScreen *gscr, unsigned long event_ma
     GdkWindow *event_win;
     PangoLayout *layout;
     long desktop_visible;
-    int i, j;
+    int i, j, k;
 
     g_return_val_if_fail (display_info, NULL);
     g_return_val_if_fail (GDK_IS_SCREEN (gscr), NULL);
@@ -308,30 +308,8 @@ myScreenInit (DisplayInfo *display_info, GdkScreen *gscr, unsigned long event_ma
     screen_info->pango_attr_list = NULL;
     screen_info->box_gc = None;
 
-    for (i = 0; i < SIDE_COUNT; i++)
-    {
-        xfwmPixmapInit (screen_info, &screen_info->sides[i][ACTIVE]);
-        xfwmPixmapInit (screen_info, &screen_info->sides[i][INACTIVE]);
-    }
-    for (i = 0; i < CORNER_COUNT; i++)
-    {
-        xfwmPixmapInit (screen_info, &screen_info->corners[i][ACTIVE]);
-        xfwmPixmapInit (screen_info, &screen_info->corners[i][INACTIVE]);
-    }
-    for (i = 0; i < BUTTON_COUNT; i++)
-    {
-        for (j = 0; j < STATE_COUNT; j++)
-        {
-            xfwmPixmapInit (screen_info, &screen_info->buttons[i][j]);
-        }
-    }
-    for (i = 0; i < TITLE_COUNT; i++)
-    {
-        xfwmPixmapInit (screen_info, &screen_info->title[i][ACTIVE]);
-        xfwmPixmapInit (screen_info, &screen_info->title[i][INACTIVE]);
-        xfwmPixmapInit (screen_info, &screen_info->top[i][ACTIVE]);
-        xfwmPixmapInit (screen_info, &screen_info->top[i][INACTIVE]);
-    }
+    screen_info->decoration = g_hash_table_new_full(NULL, NULL,
+            NULL, (GDestroyNotify)unloadSingleDecoration);
 
     screen_info->monitors_index = NULL;
     myScreenInvalidateMonitorCache (screen_info);
diff --git a/src/screen.h b/src/screen.h
index 832e3c1ff..cd60f6e3d 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -62,6 +62,8 @@
                                  HyperMask)
 
 
+#define XPM_COLOR_SYMBOL_SIZE   24
+
 #ifdef HAVE_COMPOSITOR
 
 #ifdef HAVE_PRESENT_EXTENSION
@@ -87,6 +89,15 @@ typedef enum
     VBLANK_ERROR,
 } vblankMode;
 
+struct _Decoration
+{
+    xfwmPixmap buttons[BUTTON_COUNT][STATE_COUNT];
+    xfwmPixmap corners[CORNER_COUNT][2];
+    xfwmPixmap sides[SIDE_COUNT][2];
+    xfwmPixmap title[TITLE_COUNT][2];
+    xfwmPixmap top[TITLE_COUNT][2];
+};
+
 struct _ScreenInfo
 {
     /* The display this screen belongs to */
@@ -105,11 +116,10 @@ struct _ScreenInfo
     /* Theme pixmaps and other params, per screen */
     GdkRGBA title_colors[2];
     GdkRGBA title_shadow_colors[2];
-    xfwmPixmap buttons[BUTTON_COUNT][STATE_COUNT];
-    xfwmPixmap corners[CORNER_COUNT][2];
-    xfwmPixmap sides[SIDE_COUNT][2];
-    xfwmPixmap title[TITLE_COUNT][2];
-    xfwmPixmap top[TITLE_COUNT][2];
+    GdkRGBA qubes_label_colors[MAX_QUBES_LABELS];
+    xfwmColorSymbol colsym[ XPM_COLOR_SYMBOL_SIZE + 1 ];
+    /* hash table label_color->Decoration* */
+    GHashTable *decoration;
 
     /* Per screen graphic contexts */
     GC box_gc;
diff --git a/src/settings.c b/src/settings.c
index 5567618ca..56428f021 100644
--- a/src/settings.c
+++ b/src/settings.c
@@ -46,7 +46,6 @@
 
 #define CHANNEL_XFWM            "xfwm4"
 #define THEMERC                 "themerc"
-#define XPM_COLOR_SYMBOL_SIZE   24
 
 #define KEYMAP_UPDATE_TIMEOUT   250 /* ms */
 static guint keymap_timeout   = 0;
@@ -285,10 +284,8 @@ getThemeName (ScreenInfo *screen_info, Settings *rc)
     return DEFAULT_HDPI_THEME;
 }
 
-static void
-loadTheme (ScreenInfo *screen_info, Settings *rc)
+Decoration *getDecorationForColor(ScreenInfo *screen_info, guint32 color)
 {
-
     static const char *side_names[] = {
         "left",
         "right",
@@ -322,6 +319,92 @@ loadTheme (ScreenInfo *screen_info, Settings *rc)
         "toggled-prelight",
         "toggled-pressed"
     };
+    Decoration *decoration;
+    gchar imagename[30];
+    gchar *theme;
+    guint i, j;
+
+    decoration = g_hash_table_lookup(screen_info->decoration, GINT_TO_POINTER(color));
+    if (decoration)
+        return decoration;
+
+    decoration = g_new(Decoration, 1);
+    theme = screen_info->params->theme;
+
+    for (i = 0; i < SIDE_COUNT; i++)
+    {
+        xfwmPixmapInit (screen_info, &decoration->sides[i][ACTIVE]);
+        xfwmPixmapInit (screen_info, &decoration->sides[i][INACTIVE]);
+    }
+    for (i = 0; i < CORNER_COUNT; i++)
+    {
+        xfwmPixmapInit (screen_info, &decoration->corners[i][ACTIVE]);
+        xfwmPixmapInit (screen_info, &decoration->corners[i][INACTIVE]);
+    }
+    for (i = 0; i < BUTTON_COUNT; i++)
+    {
+        for (j = 0; j < STATE_COUNT; j++)
+        {
+            xfwmPixmapInit (screen_info, &decoration->buttons[i][j]);
+        }
+    }
+    for (i = 0; i < TITLE_COUNT; i++)
+    {
+        xfwmPixmapInit (screen_info, &decoration->title[i][ACTIVE]);
+        xfwmPixmapInit (screen_info, &decoration->title[i][INACTIVE]);
+        xfwmPixmapInit (screen_info, &decoration->top[i][ACTIVE]);
+        xfwmPixmapInit (screen_info, &decoration->top[i][INACTIVE]);
+    }
+
+    for (i = 0; i < SIDE_COUNT; i++)
+    {
+        if (i == SIDE_TOP)
+            continue;  /* There is no top decoration per se. */
+
+        g_snprintf(imagename, sizeof (imagename), "%s-active", side_names[i]);
+        xfwmPixmapLoad (screen_info, &decoration->sides[i][ACTIVE], theme, imagename, screen_info->colsym, color);
+
+        g_snprintf(imagename, sizeof (imagename), "%s-inactive", side_names[i]);
+        xfwmPixmapLoad (screen_info, &decoration->sides[i][INACTIVE], theme, imagename, screen_info->colsym, color);
+    }
+    for (i = 0; i < CORNER_COUNT; i++)
+    {
+        g_snprintf(imagename, sizeof (imagename), "%s-active", corner_names[i]);
+        xfwmPixmapLoad (screen_info, &decoration->corners[i][ACTIVE], theme, imagename, screen_info->colsym, color);
+
+        g_snprintf(imagename, sizeof (imagename), "%s-inactive", corner_names[i]);
+        xfwmPixmapLoad (screen_info, &decoration->corners[i][INACTIVE], theme, imagename, screen_info->colsym, color);
+    }
+    for (i = 0; i < BUTTON_COUNT; i++)
+    {
+        for (j = 0; j < STATE_COUNT; j++)
+        {
+            g_snprintf(imagename, sizeof (imagename), "%s-%s", button_names[i], button_state_names[j]);
+            xfwmPixmapLoad (screen_info, &decoration->buttons[i][j], theme, imagename, screen_info->colsym, color);
+        }
+    }
+    for (i = 0; i < TITLE_COUNT; i++)
+    {
+        g_snprintf(imagename, sizeof (imagename), "title-%d-active", i + 1);
+        xfwmPixmapLoad (screen_info, &decoration->title[i][ACTIVE], theme, imagename, screen_info->colsym, color);
+
+        g_snprintf(imagename, sizeof (imagename), "title-%d-inactive", i + 1);
+        xfwmPixmapLoad (screen_info, &decoration->title[i][INACTIVE], theme, imagename, screen_info->colsym, color);
+
+        g_snprintf(imagename, sizeof (imagename), "top-%d-active", i + 1);
+        xfwmPixmapLoad (screen_info, &decoration->top[i][ACTIVE], theme, imagename, screen_info->colsym, color);
+
+        g_snprintf(imagename, sizeof (imagename), "top-%d-inactive", i + 1);
+        xfwmPixmapLoad (screen_info, &decoration->top[i][INACTIVE], theme, imagename, screen_info->colsym, color);
+    }
+
+    g_hash_table_insert(screen_info->decoration, GINT_TO_POINTER(color), decoration);
+    return decoration;
+}
+
+static void
+loadTheme (ScreenInfo *screen_info, Settings *rc)
+{
 
     static const char *ui_part[] = {
         "fg",
@@ -379,11 +462,9 @@ loadTheme (ScreenInfo *screen_info, Settings *rc)
         NULL
     };
 
-    gchar imagename[30];
     GValue tmp_val = { 0, };
     GValue tmp_val2 = { 0, };
     DisplayInfo *display_info;
-    xfwmColorSymbol colsym[ XPM_COLOR_SYMBOL_SIZE + 1 ];
     GtkWidget *widget;
     gchar *theme;
     const gchar *font;
@@ -441,11 +522,13 @@ loadTheme (ScreenInfo *screen_info, Settings *rc)
 
     for (i = 0; i < XPM_COLOR_SYMBOL_SIZE; i++)
     {
-        colsym[i].name = rc[i].option;
-        colsym[i].value = g_value_get_string(rc[i].value);
+        g_free(screen_info->colsym[i].name);
+        g_free(screen_info->colsym[i].value);
+        screen_info->colsym[i].name = g_strdup(rc[i].option);
+        screen_info->colsym[i].value = g_strdup(g_value_get_string(rc[i].value));
     }
-    colsym[XPM_COLOR_SYMBOL_SIZE].name = NULL;
-    colsym[XPM_COLOR_SYMBOL_SIZE].value = NULL;
+    screen_info->colsym[XPM_COLOR_SYMBOL_SIZE].name = NULL;
+    screen_info->colsym[XPM_COLOR_SYMBOL_SIZE].value = NULL;
 
     /* Standard double click time ... */
     display_info->double_click_time = abs (getIntValue ("double_click_time", rc));
@@ -477,48 +560,6 @@ loadTheme (ScreenInfo *screen_info, Settings *rc)
     gdk_rgba_parse (&screen_info->title_shadow_colors[ACTIVE], getStringValue ("active_text_shadow_color", rc));
     gdk_rgba_parse (&screen_info->title_shadow_colors[INACTIVE], getStringValue ("inactive_text_shadow_color", rc));
 
-    for (i = 0; i < SIDE_COUNT; i++)
-    {
-        if (i == SIDE_TOP)
-            continue;  /* There is no top decoration per se. */
-
-        g_snprintf(imagename, sizeof (imagename), "%s-active", side_names[i]);
-        xfwmPixmapLoad (screen_info, &screen_info->sides[i][ACTIVE], theme, imagename, colsym);
-
-        g_snprintf(imagename, sizeof (imagename), "%s-inactive", side_names[i]);
-        xfwmPixmapLoad (screen_info, &screen_info->sides[i][INACTIVE], theme, imagename, colsym);
-    }
-    for (i = 0; i < CORNER_COUNT; i++)
-    {
-        g_snprintf(imagename, sizeof (imagename), "%s-active", corner_names[i]);
-        xfwmPixmapLoad (screen_info, &screen_info->corners[i][ACTIVE], theme, imagename, colsym);
-
-        g_snprintf(imagename, sizeof (imagename), "%s-inactive", corner_names[i]);
-        xfwmPixmapLoad (screen_info, &screen_info->corners[i][INACTIVE], theme, imagename, colsym);
-    }
-    for (i = 0; i < BUTTON_COUNT; i++)
-    {
-        for (j = 0; j < STATE_COUNT; j++)
-        {
-            g_snprintf(imagename, sizeof (imagename), "%s-%s", button_names[i], button_state_names[j]);
-            xfwmPixmapLoad (screen_info, &screen_info->buttons[i][j], theme, imagename, colsym);
-        }
-    }
-    for (i = 0; i < TITLE_COUNT; i++)
-    {
-        g_snprintf(imagename, sizeof (imagename), "title-%d-active", i + 1);
-        xfwmPixmapLoad (screen_info, &screen_info->title[i][ACTIVE], theme, imagename, colsym);
-
-        g_snprintf(imagename, sizeof (imagename), "title-%d-inactive", i + 1);
-        xfwmPixmapLoad (screen_info, &screen_info->title[i][INACTIVE], theme, imagename, colsym);
-
-        g_snprintf(imagename, sizeof (imagename), "top-%d-active", i + 1);
-        xfwmPixmapLoad (screen_info, &screen_info->top[i][ACTIVE], theme, imagename, colsym);
-
-        g_snprintf(imagename, sizeof (imagename), "top-%d-inactive", i + 1);
-        xfwmPixmapLoad (screen_info, &screen_info->top[i][INACTIVE], theme, imagename, colsym);
-    }
-
     screen_info->box_gc = createGC (screen_info, "#FFFFFF", GXxor, NULL, 2, TRUE);
 
     if (!g_ascii_strcasecmp ("left", getStringValue ("title_alignment", rc)))
@@ -551,7 +592,9 @@ loadTheme (ScreenInfo *screen_info, Settings *rc)
     screen_info->params->title_horizontal_offset =
         getIntValue ("title_horizontal_offset", rc);
 
-    g_free (theme);
+    if (screen_info->params->theme)
+        g_free (screen_info->params->theme);
+    screen_info->params->theme = theme;
 }
 
 static void
@@ -911,43 +954,55 @@ loadSettings (ScreenInfo *screen_info)
     return TRUE;
 }
 
-static void
-unloadTheme (ScreenInfo *screen_info)
+void
+unloadSingleDecoration (Decoration *decoration)
 {
     int i, j;
 
     TRACE ("entering");
 
-    if (screen_info->font_desc != NULL)
-    {
-        pango_font_description_free (screen_info->font_desc);
-        screen_info->font_desc = NULL;
-    }
-
     for (i = 0; i < SIDE_COUNT; i++)
     {
-        xfwmPixmapFree (&screen_info->sides[i][ACTIVE]);
-        xfwmPixmapFree (&screen_info->sides[i][INACTIVE]);
+        xfwmPixmapFree (&decoration->sides[i][ACTIVE]);
+        xfwmPixmapFree (&decoration->sides[i][INACTIVE]);
     }
     for (i = 0; i < CORNER_COUNT; i++)
     {
-        xfwmPixmapFree (&screen_info->corners[i][ACTIVE]);
-        xfwmPixmapFree (&screen_info->corners[i][INACTIVE]);
+        xfwmPixmapFree (&decoration->corners[i][ACTIVE]);
+        xfwmPixmapFree (&decoration->corners[i][INACTIVE]);
     }
     for (i = 0; i < BUTTON_COUNT; i++)
     {
         for (j = 0; j < STATE_COUNT; j++)
         {
-            xfwmPixmapFree (&screen_info->buttons[i][j]);
+            xfwmPixmapFree (&decoration->buttons[i][j]);
         }
     }
     for (i = 0; i < TITLE_COUNT; i++)
     {
-        xfwmPixmapFree (&screen_info->title[i][ACTIVE]);
-        xfwmPixmapFree (&screen_info->title[i][INACTIVE]);
-        xfwmPixmapFree (&screen_info->top[i][ACTIVE]);
-        xfwmPixmapFree (&screen_info->top[i][INACTIVE]);
+        xfwmPixmapFree (&decoration->title[i][ACTIVE]);
+        xfwmPixmapFree (&decoration->title[i][INACTIVE]);
+        xfwmPixmapFree (&decoration->top[i][ACTIVE]);
+        xfwmPixmapFree (&decoration->top[i][INACTIVE]);
     }
+}
+
+static void
+unloadTheme (ScreenInfo *screen_info)
+{
+    TRACE ("entering");
+
+    if (screen_info->font_desc != NULL)
+    {
+        pango_font_description_free (screen_info->font_desc);
+        screen_info->font_desc = NULL;
+    }
+
+    g_hash_table_remove_all(screen_info->decoration);
+
+    g_free(screen_info->params->theme);
+    screen_info->params->theme = NULL;
+
     if (screen_info->box_gc != None)
     {
         XFreeGC (myScreenGetXDisplay (screen_info), screen_info->box_gc);
diff --git a/src/settings.h b/src/settings.h
index f20c6db46..9f4000f6a 100644
--- a/src/settings.h
+++ b/src/settings.h
@@ -163,6 +163,33 @@ enum
     PLACE_CENTER
 };
 
+enum
+{
+    QUBES_LABEL_DOM0 = 0,
+    QUBES_LABEL_RED = 1,
+    QUBES_LABEL_ORANGE = 2,
+    QUBES_LABEL_YELLOW = 3,
+    QUBES_LABEL_GREEN = 4,
+    QUBES_LABEL_GRAY = 5,
+    QUBES_LABEL_BLUE = 6,
+    QUBES_LABEL_PURPLE = 7,
+    QUBES_LABEL_BLACK = 8,
+    MAX_QUBES_LABELS = 9
+};
+
+/* RGB values */
+static const guint qubes_label_colors[] = {
+    0xFFFFFFFF, /* QUBES_LABEL_DOM0 */
+    0xcc0000,   /* QUBES_LABEL_RED */
+    0xf57900,   /* QUBES_LABEL_ORANGE */
+    0xedd400,   /* QUBES_LABEL_YELLOW */
+    0x73d216,   /* QUBES_LABEL_GREEN */
+    0x555753,   /* QUBES_LABEL_GRAY */
+    0x3465a4,   /* QUBES_LABEL_BLUE */
+    0x75507b,   /* QUBES_LABEL_PURPLE */
+    0x000000,   /* QUBES_LABEL_BLACK */
+};
+
 struct _Settings
 {
     gchar  *option;
@@ -199,6 +226,7 @@ struct _XfwmParams
     int shadow_delta_y;
     int shadow_opacity;
     int snap_width;
+    gchar *theme;
     int title_alignment;
     int title_horizontal_offset;
     int title_shadow[2];
@@ -252,5 +280,9 @@ gboolean                 reloadSettings                         (DisplayInfo *,
                                                                  int);
 gboolean                 initSettings                           (ScreenInfo *);
 void                     closeSettings                          (ScreenInfo *);
+void                     unloadSingleDecoration                 (Decoration *decoration);
+Decoration *getDecorationForColor(ScreenInfo *screen_info, guint32 color);
+
+#define QUBES_LABEL_DOM0 0xFFFFFFFF
 
 #endif /* INC_SETTINGS_H */
-- 
2.25.4

